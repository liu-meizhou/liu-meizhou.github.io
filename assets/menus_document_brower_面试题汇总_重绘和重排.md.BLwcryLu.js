import{_ as t,c as l,e as i,a1 as a}from"./chunks/framework.C-01xEl2.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"menus/document/brower/面试题汇总/重绘和重排.md","filePath":"menus/document/brower/面试题汇总/重绘和重排.md","lastUpdated":1707281529000}'),o={name:"menus/document/brower/面试题汇总/重绘和重排.md"};function n(r,e,c,p,d,s){return i(),l("div",null,e[0]||(e[0]=[a('<h2 id="重绘和重排" tabindex="-1">重绘和重排 <a class="header-anchor" href="#重绘和重排" aria-label="Permalink to &quot;重绘和重排&quot;">​</a></h2><p>重绘（Repaint）和重排（Reflow）是与页面渲染相关的两个概念。</p><p>重绘指的是当元素的样式发生改变，但不影响其在文档流中的位置和大小时，浏览器会重新绘制（repaint）该元素，将新的样式应用到元素上，但不会改变元素的布局。</p><p>重排指的是当元素的布局发生改变，例如改变元素的位置、大小、显示/隐藏等，浏览器会重新计算（reflow）并更新整个页面的布局，重新确定元素的位置和大小。</p><p>重绘和重排的触发条件包括：</p><ul><li>重绘：元素的样式发生改变，例如颜色、背景、边框等。</li><li>重排：元素的布局发生改变，例如添加或删除元素、改变元素的尺寸、改变元素的位置等。</li></ul><p>重绘和重排的频繁发生会影响页面的性能和用户体验，因为它们会消耗CPU和内存资源。为了优化页面性能，可以采取以下几个方法：</p><ol><li>减少重绘和重排的次数：合并多个样式改变的操作，避免频繁地修改元素的样式和布局。</li><li>使用CSS动画和过渡：使用CSS的transform和opacity等属性进行动画效果，可以减少重绘和重排的次数。</li><li>使用文档片段（Document Fragment）：在DOM操作较多时，可以使用文档片段进行批量操作，减少重排的次数。</li><li>避免强制同步布局：避免在读取布局信息之前立即修改布局，例如在循环中频繁读取元素的位置和大小。</li><li>使用CSS属性will-change：通过使用will-change属性，可以提前告知浏览器元素将要发生的变化，从而优化重排的性能。</li></ol><p>综上所述，减少重绘和重排的次数是优化页面性能的关键，可以通过合理的CSS设计和DOM操作来减少重绘和重排的发生，提升页面的渲染效率和用户体验。</p><h2 id="常见的引起重排属性和方法" tabindex="-1">常见的引起重排属性和方法 <a class="header-anchor" href="#常见的引起重排属性和方法" aria-label="Permalink to &quot;常见的引起重排属性和方法&quot;">​</a></h2><p>任何会改变元素的位置和尺寸大小的操作，都会触发重排。常见的例子如下：</p><ul><li>添加或删除可见的DOM元素</li><li>元素尺寸改变</li><li>内容变化，比如在input框中输入文字</li><li>浏览器窗口尺寸改变</li><li>计算offsetTop、offsetLeft等布局信息</li><li>设置style属性的值</li><li>激活CSS伪类，例如 :hover</li><li>查询某些属性或调用某些方法 <ul><li>获取布局信息的属性或方法</li></ul></li></ul><h3 id="获取布局信息的属性或方法" tabindex="-1">获取布局信息的属性或方法 <a class="header-anchor" href="#获取布局信息的属性或方法" aria-label="Permalink to &quot;获取布局信息的属性或方法&quot;">​</a></h3><ul><li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li><li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li><li>clientTop、clientLeft、clientWidth、clientHeight</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li></ul><p>看到这里有的人可能会疑惑，我们只是获取这些属性值，并没有改变它，为什么会触发重排？</p><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制清空队列，因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。</p><h2 id="getboundingclientrect" tabindex="-1">getBoundingClientRect <a class="header-anchor" href="#getboundingclientrect" aria-label="Permalink to &quot;getBoundingClientRect&quot;">​</a></h2><p>Element.getBoundingClientRect() 方法返回一个 DOMRect 对象，其提供了元素的大小及其相对于视口的位置。</p><p>返回值是一个 DOMRect 对象，是包含整个元素的最小矩形（包括 padding 和 border-width）。该对象使用 left、top、right、bottom、x、y、width 和 height 这几个以像素为单位的只读属性描述整个矩形的位置和大小。除了 width 和 height 以外的属性是相对于视图窗口的左上角来计算的。</p>',19)]))}const f=t(o,[["render",n]]);export{u as __pageData,f as default};
