import{_ as i,c as a,e,a1 as l}from"./chunks/framework.C-01xEl2.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"menus/document/css/面试题汇总/隐藏元素的方法.md","filePath":"menus/document/css/面试题汇总/隐藏元素的方法.md","lastUpdated":1707281529000}'),d={name:"menus/document/css/面试题汇总/隐藏元素的方法.md"};function s(r,t,o,n,h,c){return e(),a("div",null,t[0]||(t[0]=[l('<h2 id="隐藏元素的方法" tabindex="-1">隐藏元素的方法 <a class="header-anchor" href="#隐藏元素的方法" aria-label="Permalink to &quot;隐藏元素的方法&quot;">​</a></h2><ol><li>display: none：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li>visibility: hidden：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li>opacity: 0：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li>position: absolute：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li>z-index: 负值：来使其他元素遮盖住该元素，以此来实现隐藏。</li><li>transform: scale(0,0)：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ol><h2 id="display和visibility的区别" tabindex="-1">display和visibility的区别 <a class="header-anchor" href="#display和visibility的区别" aria-label="Permalink to &quot;display和visibility的区别&quot;">​</a></h2><table tabindex="0"><thead><tr><th></th><th>display: none</th><th>visibility: hidden</th></tr></thead><tbody><tr><td>渲染树</td><td>不存在</td><td>存在</td></tr><tr><td>隐藏方式</td><td>不在渲染树中，不会被渲染</td><td>靠继承进行隐藏，通过改子元素的visibility可以显示子元素</td></tr><tr><td>显隐改变</td><td>改变display通常会改变布局，造成重排</td><td>改变只会造成重绘</td></tr></tbody></table><h2 id="关联面试题" tabindex="-1">关联面试题 <a class="header-anchor" href="#关联面试题" aria-label="Permalink to &quot;关联面试题&quot;">​</a></h2><ul><li><a href="./../属性/display.html">display</a></li><li><a href="./../属性/position.html">position</a></li><li><a href="./../属性/transform.html">transform</a></li><li><a href="/menus/document/brower/面试题汇总/重绘和重排.html">重绘和重排</a></li></ul>',6)]))}const u=i(d,[["render",s]]);export{p as __pageData,u as default};
