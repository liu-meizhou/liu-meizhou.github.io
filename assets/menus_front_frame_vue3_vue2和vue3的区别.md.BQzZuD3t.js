import{_ as l,c as a,e as t,a1 as i}from"./chunks/framework.C-01xEl2.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"menus/front_frame/vue3/vue2和vue3的区别.md","filePath":"menus/front_frame/vue3/vue2和vue3的区别.md","lastUpdated":1708660566000}'),o={name:"menus/front_frame/vue3/vue2和vue3的区别.md"};function u(r,e,n,d,s,c){return t(),a("div",null,e[0]||(e[0]=[i('<h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://v3-migration.vuejs.org/zh/" target="_blank" rel="noreferrer">vue3升级指南</a></li><li><strong>理解改动的同时要明白为什么要这样改，这样改的优点在哪？</strong></li></ul><h2 id="新特性" tabindex="-1">新特性 <a class="header-anchor" href="#新特性" aria-label="Permalink to &quot;新特性&quot;">​</a></h2><ul><li>Composition API(组合式API、hooks)</li><li>setup语法糖</li></ul><h2 id="非兼容性改变" tabindex="-1">非兼容性改变 <a class="header-anchor" href="#非兼容性改变" aria-label="Permalink to &quot;非兼容性改变&quot;">​</a></h2><h3 id="全局api" tabindex="-1">全局API <a class="header-anchor" href="#全局api" aria-label="Permalink to &quot;全局API&quot;">​</a></h3><ul><li>全局Vue API更改为使用应用程序实例 <ul><li>Vue 2 没有“app”的概念，我们定义的应用只是通过 new Vue() 创建的根 Vue 实例。从同一个 Vue 构造函数创建的每个根实例共享相同的全局配置。在测试期间，全局配置很容易意外地污染其他测试用例。</li></ul></li><li>全局API Tree-shaking <ul><li>Vue2.x如<code>Vue.nextTick()</code>这样的全局api是不支持tree-shaking的，vue3.x全局 API 现在通过具名导出进行访问<code>import { nextTick } from &#39;vue&#39;</code>可以让打包工具支持tree-shaking</li></ul></li></ul><h3 id="模板指令" tabindex="-1">模板指令 <a class="header-anchor" href="#模板指令" aria-label="Permalink to &quot;模板指令&quot;">​</a></h3><ul><li>v-model: 这是这个语法糖，会解析成v-bind和v-on <ul><li>vue2.x中解析成:value和@input；vue3.x解析成:modelValue和update:modelValue并且v-model支持添加参数如<code>v-model:version</code>也支持添加修饰符如<code>v-model.trim</code>并且可以一次绑定多个v-model</li></ul></li><li>v-if 与 v-for 的优先级对比 <ul><li>2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。而vue3.x相反。</li></ul></li><li>v-bind 合并行为 <ul><li>在 2.x 中，如果一个元素同时定义了 <code>v-bind=&quot;object&quot;</code> 和一个相同的独立 <code>attribute</code>，那么这个独立 <code>attribute</code> 总是会覆盖 object 中的绑定。而3.x中绑定的声明顺序将决定它们如何被合并</li></ul></li></ul><h3 id="渲染函数" tabindex="-1">渲染函数 <a class="header-anchor" href="#渲染函数" aria-label="Permalink to &quot;渲染函数&quot;">​</a></h3><ul><li>渲染函数API <ul><li>render() 在2.x中接受参数h表示渲染函数，而3.x渲染函数h是全局导入的，h函数的参数传入VNode现在有一个扁平的prop结构</li></ul></li><li>插槽统一 <ul><li>h函数中2.x的$scopedSlots移除，统一使用$slots访问插槽，3.x可以使用useSlots()获取插槽对象</li></ul></li><li>$listeners合并到$attrs</li><li>$attrs包含class和style <ul><li>Vue 2 的虚拟 DOM 实现对 class 和 style attribute 有一些特殊处理。因此，与其它所有 attribute 不一样，它们没有被包含在 $attrs 中。</li></ul></li></ul><h3 id="移除部分api" tabindex="-1">移除部分API <a class="header-anchor" href="#移除部分api" aria-label="Permalink to &quot;移除部分API&quot;">​</a></h3><ul><li>按键的修饰符 由键码改成别名 <ul><li><code>&lt;input v-on:keyup.13=&quot;submit&quot; /&gt;</code> 改为 <code>&lt;input v-on:keyup.enter=&quot;submit&quot; /&gt;</code></li></ul></li></ul>',13)]))}const m=l(o,[["render",u]]);export{v as __pageData,m as default};
