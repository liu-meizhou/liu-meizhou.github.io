import{_ as a,c as t,e as n,a1 as r}from"./chunks/framework.C-01xEl2.js";const i="/assets/vue.lifecycle.MuZLBFAS.png",s="/assets/render.pipeline.CwxnH_lZ.png",_=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"menus/front_frame/vue3/base/index.md","filePath":"menus/front_frame/vue3/base/index.md","lastUpdated":1707281529000}'),l={name:"menus/front_frame/vue3/base/index.md"};function o(d,e,c,p,m,u){return n(),t("div",null,e[0]||(e[0]=[r('<h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><p><img src="'+i+'" alt="vueLifecycle" loading="lazy"></p><h2 id="渲染机制" tabindex="-1">渲染机制 <a class="header-anchor" href="#渲染机制" aria-label="Permalink to &quot;渲染机制&quot;">​</a></h2><p>从高层面的视角看，Vue 组件挂载时会发生如下几件事：</p><ol><li>编译：Vue 模板被编译为渲染函数：即用来返回虚拟 DOM 树的函数。这一步骤可以通过构建步骤提前完成，也可以通过使用运行时编译器即时完成。</li><li>挂载：运行时渲染器调用渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。这一步会作为响应式副作用执行，因此它会追踪其中所用到的所有响应式依赖。</li><li>更新：当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟 DOM 树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。</li></ol><p><img src="'+s+'" alt="vueRenderPipeline" loading="lazy"></p>',6)]))}const h=a(l,[["render",o]]);export{_ as __pageData,h as default};
