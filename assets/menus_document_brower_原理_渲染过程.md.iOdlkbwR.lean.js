import{_ as s,c as a,e as l,a1 as e}from"./chunks/framework.C-01xEl2.js";const t="/assets/path.CyUJsjTJ.svg",u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"menus/document/brower/原理/渲染过程.md","filePath":"menus/document/brower/原理/渲染过程.md","lastUpdated":1707281529000}'),h={name:"menus/document/brower/原理/渲染过程.md"};function n(r,i,d,p,o,k){return l(),a("div",null,i[0]||(i[0]=[e('<h2 id="渐进式渲染" tabindex="-1">渐进式渲染 <a class="header-anchor" href="#渐进式渲染" aria-label="Permalink to &quot;渐进式渲染&quot;">​</a></h2><ul><li>如果浏览器获取到<code>html</code>就立即渲染，那么随之而来的<code>css</code>和<code>js</code>会立即破坏现有的<code>html</code>，导致页面不断发生变化，消耗性能且用户操作不了。这样用户体验差</li><li>如果浏览器等获取完整的<code>html</code>、<code>css</code>和<code>js</code>再进行渲染，如果有一个资源请求超时，那么用户就会等很久，如果这不是一个必要资源，那么这种阻塞是完全没有必要的</li><li>这时候我们需要明白浏览器到底是何时开始进行渲染的，会渲染什么内容 <ul><li>关键路径渲染</li></ul></li></ul><h3 id="关键路径渲染" tabindex="-1">关键路径渲染 <a class="header-anchor" href="#关键路径渲染" aria-label="Permalink to &quot;关键路径渲染&quot;">​</a></h3><p>渲染路径涉及以下步骤：(只有在完成所有这些步骤之后，用户才会在屏幕上看到内容。)</p><ol><li>通过 HTML 构建文档对象模型 (DOM)。</li><li>通过 CSS 构建 CSS 对象模型 (CSSOM)。</li><li>应用任何可更改 DOM 或 CSSOM 的 JavaScript。</li><li>通过 DOM 和 CSSOM 构建渲染树。</li><li>在页面上执行样式和布局操作，以查看哪些元素适合放置。</li><li>绘制内存中元素的像素。</li><li>如果有任何像素重叠，则合成像素。</li><li>以物理方式将生成的所有像素绘制到屏幕上。</li></ol><p><img src="'+t+'" alt="渲染流程" loading="lazy"></p><h3 id="关键渲染路径的资源" tabindex="-1">关键渲染路径的资源 <a class="header-anchor" href="#关键渲染路径的资源" aria-label="Permalink to &quot;关键渲染路径的资源&quot;">​</a></h3><p>浏览器需要等待一些关键资源下载完毕，然后才能完成初始渲染。这些资源包括：</p><ul><li>是 HTML 的一部分。</li><li><code>&lt;head&gt;</code>元素中阻塞渲染的 CSS。</li><li><code>&lt;head&gt;</code>元素中的阻止呈现的 JavaScript。</li></ul><p>关键在于浏览器以流式方式处理 HTML。浏览器一旦获取页面 HTML 的任何部分，便开始处理、显示它。</p><h3 id="阻塞渲染的资源" tabindex="-1">阻塞渲染的资源 <a class="header-anchor" href="#阻塞渲染的资源" aria-label="Permalink to &quot;阻塞渲染的资源&quot;">​</a></h3><ul><li>当浏览器看到 CSS（无论是 <code>&lt;style&gt;</code> 元素中的内嵌 CSS，还是 <code>&lt;link rel=stylesheet href=&quot;...&quot;&gt;</code> 元素指定的外部引用资源）时，浏览器会避免再渲染任何内容，直到完成对该 CSS 的下载和处理为止。</li><li>可以通过更改 <code>&lt;link&gt;</code> 元素的 media 属性来指定与当前条件不匹配的值，以将其转换为不阻止呈现的资源</li></ul><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">stylesheet</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;...&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> media</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>异步加载CSS的最简单方法</li></ul><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;stylesheet&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;...&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> media</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;print&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">media</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;all&#39;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li><p>在Firefox、Chrome浏览器中，css不阻塞css之前的html渲染</p></li><li><p>css不阻塞解析器解析html</p><ul><li>资源阻塞渲染并不一定意味着浏览器会阻止浏览器执行其他操作。浏览器会尽可能地提高效率，因此当浏览器发现需要下载某项 CSS 资源时，它会请求该资源并暂停呈现，但仍会继续处理其余 HTML 并查找在此期间进行的其他工作。</li></ul></li></ul><h3 id="阻塞解析器的资源" tabindex="-1">阻塞解析器的资源 <a class="header-anchor" href="#阻塞解析器的资源" aria-label="Permalink to &quot;阻塞解析器的资源&quot;">​</a></h3><ul><li>JavaScript 在默认情况下会阻止解析器（除非明确标记为<code>async</code>或<code>defer</code>） <ul><li>因为 JavaScript 可能会在执行时更改 DOM 或 CSSOM。因此，浏览器在处理 JavaScript 请求之前，需要等待所有CSS资源获取并解析完毕，在执行时，不能继续处理其他资源。</li></ul></li></ul><h3 id="不阻塞资源" tabindex="-1">不阻塞资源 <a class="header-anchor" href="#不阻塞资源" aria-label="Permalink to &quot;不阻塞资源&quot;">​</a></h3><ul><li>浏览器通常将字体和图片视为要在后续页面重新渲染期间填充的内容，因此它们不需要延迟初始渲染。当需要图片时，系统会为图片留下空白区域，如果没有<strong>设置固定的宽高</strong>，这些图片获取后会改变页面布局，引起重排</li></ul><h3 id="预加载扫描器" tabindex="-1">预加载扫描器 <a class="header-anchor" href="#预加载扫描器" aria-label="Permalink to &quot;预加载扫描器&quot;">​</a></h3><ul><li>浏览器的预加载扫描器会扫描原始HTML，发现需要加载的资源列表(图片、css、js等资源)，当发生阻塞时，预加载扫描器就会去预加载这些资源。下面这些情况预加载扫描器发现不了： <ul><li>由CSS使用background-image属性加载的图片</li><li>动态加载的脚本，使用js注入dom的script或使用动态import()加载的模块</li><li>CSS的@import声明</li></ul></li><li>上面情况如需预加载，可使用<code>preload</code>标识来进行预加载</li></ul><h2 id="查看网站渲染过程" tabindex="-1">查看网站渲染过程 <a class="header-anchor" href="#查看网站渲染过程" aria-label="Permalink to &quot;查看网站渲染过程&quot;">​</a></h2><ul><li><a href="https://www.webpagetest.org/" target="_blank" rel="noreferrer">webpagetest网站</a></li><li>浏览器的performance面板</li></ul>',24)]))}const g=s(h,[["render",n]]);export{u as __pageData,g as default};
