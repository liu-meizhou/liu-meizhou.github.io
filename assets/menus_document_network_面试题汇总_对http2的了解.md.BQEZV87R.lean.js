import{_ as a,c as e,e as l,a1 as o}from"./chunks/framework.C-01xEl2.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"menus/document/network/面试题汇总/对http2的了解.md","filePath":"menus/document/network/面试题汇总/对http2的了解.md","lastUpdated":1707281529000}'),i={name:"menus/document/network/面试题汇总/对http2的了解.md"};function r(h,t,n,d,s,p){return l(),e("div",null,t[0]||(t[0]=[o('<h2 id="请求优化" tabindex="-1">请求优化 <a class="header-anchor" href="#请求优化" aria-label="Permalink to &quot;请求优化&quot;">​</a></h2><ol><li>http1.1的请求的连接可以keep-alive，但是同个连接中下一个请求得等到上一个返回才能发送，出现了请求阻塞的问题。</li><li>http2使用多路复用进行解决。每个包做了标记，这样上个连接的包无需等到请求返回，下一个包就可以用同个连接发送请求。提高tcp利用率。但是当网络阻塞的时候，http2底层tcp有拥塞控制手段，减少滑动窗口的大小，这时候发送请求还是会比较慢。</li><li>http3使用udp来实现，在应用层实现传输的可靠性。</li></ol><h2 id="二进制分帧" tabindex="-1">二进制分帧 <a class="header-anchor" href="#二进制分帧" aria-label="Permalink to &quot;二进制分帧&quot;">​</a></h2><ol><li>http2会二进制分针，一个流就是一个完整请求的过程，一个流又被分成多个帧，连接中同时发送多帧提高并发数。</li></ol><h2 id="请求包头部压缩" tabindex="-1">请求包头部压缩 <a class="header-anchor" href="#请求包头部压缩" aria-label="Permalink to &quot;请求包头部压缩&quot;">​</a></h2><ol><li>http1.1每次请求都发送请求头，响应都会发送响应头，里面大部分都是重复。</li><li>http2使用专门的算法，每次请求和响应只发送差异头部，一般可以达到 50%~90% 的高压缩率。</li></ol><h2 id="请求优先级" tabindex="-1">请求优先级 <a class="header-anchor" href="#请求优先级" aria-label="Permalink to &quot;请求优先级&quot;">​</a></h2><ol><li>http2在有限的带宽下，高优先级的请求会被优先处理</li></ol><h2 id="服务端推送" tabindex="-1">服务端推送 <a class="header-anchor" href="#服务端推送" aria-label="Permalink to &quot;服务端推送&quot;">​</a></h2><ol><li>http2可以由服务器主动把资源文件推送给客户端(当然客户端也有权力选择拒收)</li></ol>',10)]))}const m=a(i,[["render",r]]);export{u as __pageData,m as default};
