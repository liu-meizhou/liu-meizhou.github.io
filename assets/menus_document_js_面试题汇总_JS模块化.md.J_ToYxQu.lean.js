import{_ as o,c as a,e as t,a1 as l}from"./chunks/framework.C-01xEl2.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"menus/document/js/面试题汇总/JS模块化.md","filePath":"menus/document/js/面试题汇总/JS模块化.md","lastUpdated":1707281529000}'),s={name:"menus/document/js/面试题汇总/JS模块化.md"};function r(d,e,i,n,c,m){return t(),a("div",null,e[0]||(e[0]=[l('<h2 id="commonjs" tabindex="-1">commonjs <a class="header-anchor" href="#commonjs" aria-label="Permalink to &quot;commonjs&quot;">​</a></h2><p>nodejs中采用的默认模块化规范，语法: <code>require(&#39;xxx&#39;)</code></p><p>导入: <code>module.exports = xxx</code></p><h2 id="es6模块化" tabindex="-1">es6模块化 <a class="header-anchor" href="#es6模块化" aria-label="Permalink to &quot;es6模块化&quot;">​</a></h2><p>语法: <code>import</code></p><p>导入: <code>exports default xxx</code></p><h2 id="两者区别" tabindex="-1">两者区别 <a class="header-anchor" href="#两者区别" aria-label="Permalink to &quot;两者区别&quot;">​</a></h2><ol><li>引入方式 <ol><li>commonjs可以在任意地方引入，是动态导入的</li><li>esModule是静态导入(在编译阶段进行导入)，不能写于块级作用域中</li></ol></li><li>使用语法差别</li><li>模块导出导入 <ol><li>commonjs导出的是module.exports，导入其实就是给变量复制，原始类型是拷贝，但引用类型就是地址赋值</li><li>esModule导出的是值的只读引用地址，当导出模块内部值发生改变时，导入的也会改变</li></ol></li></ol>',8)]))}const x=o(s,[["render",r]]);export{u as __pageData,x as default};
